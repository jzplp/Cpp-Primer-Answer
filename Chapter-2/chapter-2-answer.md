* **练习2.1**  
位数不同，能表示的整数范围大小不同。  
无符号类型只能表示大于等于0的数。有符号则也可以表示小于0的数。  
float和double位数不同，能表示的浮点数精度和范围不同。  

* **练习2.2**  
利率： 浮点数，比如float  
本金： 整数，比如int  
付款： 浮点数，比如double  
因为利率一般都不是整数，本金是整数，最后的付款可能也不是整数。  

* **练习2.3**  
输出结果为：  
32  
MAX-32  
32  
-32  
0  
0  
其中 MAX是int类型的最大值+1。

* **练习2.4**  
[2.4程序代码](2.4.cpp)   
结果证明2.3的估计正确。

* **练习2.5**  
```
(a)
'a'     char
L'a'    wchar_t
"a"     char数组
L"a"    wchar_t数组
(b)
10      int
10u     unsigned int
10L     long
10uL    unsigned long
012     八进制int
0xC     16进制int
(c)
3.14    double
3.14f   float
3.14L   long double
(d)
10      int
10u     unsigned int
10.     double
10e-2   double
```  

* **练习2.6**  
有区别。  
9并不是8进制中的数字，所以09会发生编译错误。

* **练习2.7**  
(a)  
含义： "What goes with Fergus? \n"  
类型：char数组  
(b)  
含义： 31.4  
类型：long double  
(c)  
含义： 1024.0  
类型：float  
(d)  
含义： 3.14  
类型：long double  

* **练习2.8**  
[2.8程序代码](2.8.cpp)  

* **练习2.9**  
(a) 不能对定义语句进行运算操作。  
改正：
```
int input_value;
std::cin >> input_value;
```
(b) 错误，花括号的初始化形式不支持丢失信息的初始化。  
改正：
```
int i = (3.14);
```
(c) 如果wage之前已经定义，则正确，如果未定义则错误。  
改正：
```
double wage = 9999.99 , salary = wage;
```

(d) 正确，但是会损失小数部分。

* **练习2.10**  
global_str 初值 空字符串  
global_int 初值 0  
local_int 初值 未定义  
local_str 初值 空字符串

* **练习2.11**  
(a) 定义 (b) 定义 (c) 声明 

* **练习2.12**  
(a) 非法 (b) 合法 (c) 非法 (d) 非法 (e) 合法 

* **练习2.13**  
j的值位100

* **练习2.14**  
合法  
输出: 100 45

* **练习2.15**  
(a) 合法  
(b) 不合法 引用不能绑定在字面值上  
(c) 如果ival为浮点数则不合法  
(d) 不合法 引用定义的时候没有初始化  

* **练习2.16**  
(a) 合法 给d赋值  
(b) 合法 i给d赋值，并隐式转换了类型  
(c) 合法 d给i赋值，并隐式转换了类型  
(d) 合法 d给i赋值，并隐式转换了类型

* **练习2.17**  
输出：  
10 10

* **练习2.18**  
[2.18程序代码](2.18.cpp)  

* **练习2.19**  
1. 指针本身是对象，有内存空间，引用没有
2. 指针可以改变指向的对象，引用不可以
3. 指针定义是可以不指定指向的对象，引用不可以
4. 指针有空指针，或者不指向对象，引用不可以  
等等

* **练习2.20**  
计算i的值的平方，最后i的值为1764  

* **练习2.21**  
(a) 非法 指针类型错误  
(b) 非法 指针不能直接赋值为int  
(c) 合法

* **练习2.22**  
1. 如果p指向了一个对象
2. 如果p指向的对象值不为0  

* **练习2.23**  
不能。因为即使指向“非法对象”，有时候也能正常得到结果。所以无法判断。

* **练习2.24**  
因为void指针能指向任何类型的对象。但是long指针和int指针是不同的，不能混用。

* **练习2.25**  
(a)  
ip: 指向int的指针变量，值未定义  
i:  int类型变量，值未定义  
r:  int类型的引用，值为i的值  
(b)  
i:  int类型变量，值未定义  
ip: 指向int的指针变量，值为0  
(c)  
ip: 指向int的指针变量，值未定义  
ip2:  int类型变量，值未定义  

* **练习2.26**  
(a) 不合法。const常量必须初始化  
(b) 合法  
(c) 合法  
(d) ++cnt; 合法  
++sz; 不合法 因为sz是常量

* **练习2.27**  
(a) r不合法  
(b) 合法(如果i2是一个int变量)  
(c) 合法  
(d) 合法  
(e) 合法  
(f) 不合法  
(g) 合法

* **练习2.28**  
(a) cp不合法 常量指针必须初始化  
(b) p2不合法 常量指针必须初始化  
(c) 合法  
(d) 不合法 常量指针必须初始化  
(e) 合法  

* **练习2.29**  
(a) 合法  
(b) 不合法 指向常量的指针不能赋值给指向变量的指针  
(c) 不合法 指向常量的地址不能赋值给指向变量的指针  
(d) 不合法 常量指针的值不能改变  
(e) 不合法 常量指针的值不能改变  
(f) 不合法 常量的值不能改变

 * **练习2.30**  
v2 顶层const  
p2 底层const  
p3 顶层+底层const  
r2 底层const  
注：答案书上未把p3标为底层const，答案书错误。

* **练习2.31**  
r1 = v2 合法  
p1 = p2 不合法  
p2 = p1 合法  
p1 = p3 不合法  
p2 = p3 合法  

* **练习2.32**  
非法  改为
```
int null = 0 , *p = &null;
```

* **练习2.33**  
```
a = 42; a的值变为42
b = 42; b的值变为42
c = 42; c的值变为42
d = 42; 编译器Error 不能给指针赋值int常量(除0之外)
e = 42; 编译器Error 不能给指针赋值int常量(除0之外)
g = 42; 编译器Error 不能给int常量的引用赋值
```

* **练习2.34**  
[2.34程序代码](2.34.cpp)  
注释的部分是编译器Error的语句。  
推论正确。

* **练习2.35**  
[2.35程序代码](2.35.cpp)  
i int常量  
j int变量  
k int常量的引用  
p int常量的指针(auto后面的*可以不加)  
j2 int常量  
k2 int常量的引用  

* **练习2.36**  
a int变量 4  
b int变量 4  
c int变量 4  
d int引用 4  

* **练习2.37**  
a int变量 3  
b int变量 4  
c int变量 3  
d int引用 3  

* **练习2.38**  
auto是根据初始化的类型来判断，decltype是根据一个额外的表达式来判断类型。  
```
类型一样的情况：
int i = 0;
auto a = i;
decltype(i) b; 
类型不一样的情况：
int i = 0，&j = i;
auto a = j;
decltype(j) b = i; 
```

* **练习2.39**  
[2.39错误程序代码](2.39.cpp)  
会发生编译错误。错误信息：  
[Error] expected ';' after struct definition

* **练习2.40**  
[2.40程序代码](2.40.cpp)  

* **练习2.41**  
[重写1.20程序代码](2.41/2.41_1.20.cpp)  
[重写1.21程序代码](2.41/2.41_1.21.cpp)  
[重写1.22程序代码](2.41/2.41_1.22.cpp)  
[重写1.23程序代码](2.41/2.41_1.23.cpp)  
[重写1.25程序代码](2.41/2.41_1.25.cpp)  
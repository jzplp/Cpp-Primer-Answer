* **练习4.1**  
求值结果为105  

* **练习4.2**  
```
(a) *(vec.begin())  
(b) (*(vec.begin())) + 1
```

* **练习4.3**  
我认为可以接受。因为大部分时候可以规避在同一表达式同时修改同一对象。
（不成熟的看法）

* **练习4.4**  
[4.4验证程序代码](4.4.cpp)  
```
(((12 / 3) * 4) + (5 * 15)) + ((24 % 4) / 2)
```

* **练习4.5**  
(a) -86  
(b) -18  
(c) 42  
(d) -2

* **练习4.6**  
x%2

* **练习4.7**  
```
12*10000000000000000000000
INT_MAX + 1
INT_MAX * 2
```

* **练习4.8**  
```
 先求值 && 后求值
 先求值 || 后求值
 == 无规定求值顺序 
```

* **练习4.9**  
首先判断cp是否为空指针，如果不是空指针，则判断cp[0]的值是否为'\0'。

* **练习4.10**  
```
while(std::cin >> a && a != 42)
```
* **练习4.11**  
a > b && b > c && c > d

* **练习4.12**  
首先判断j是否小于k  
如果j小于k，则判断i是否不等于1  
如果j不小于k，则判断i是否不等于0

* **练习4.13**  
(a) i的值为3，d的值为3.0  
(b) i的值为3，d的值为3.5

* **练习4.14**  
```
if (42 = i)
编译错误，无法执行
if (i = 42)
42赋值给i，并进入if语句执行
```
* **练习4.15**  
错误原因：指针不能赋值给int  
修改：
```
pi = 0;
dval = ival = 0;
```

* **练习4.16**  
(a) 程序会首先计算getPtr()函数值和0进行比较是否相等，然后把比较结果赋值给p。另外getPtr()函数值被计算了两遍。  
修改：
```
if((p = getPtr()) != 0)
```
(b) c程序会首先把1024赋值给i,然后再把i的值转换为bool型看是否为true。  
修改：
```
if(i == 1024)
```

* **练习4.17**  
前置递增运算符返回加1之后的对象，是左值。  
后置递增运算符返回加1之前的对象，是右值。

* **练习4.18**  
不会输出第一个元素，并且会输出最后一个元素后面位置的内容。

* **练习4.19**  
(a) 含义：ptr是否为空指针而且ptr的内容是否为0，并且把ptr的值+1（如果ptr非空）。  
(b) 表达式不正确，修改为：
```
ii = ival;
++ival && ii
```  
ival和ival+1的值是否都不为0  
(c) 表达式不正确，修改为：
```
ii = ival;
vec[ii] <= vec[++ival]
```
判断vec[ival+1]是否大于vec[ival]

* **练习4.20**  
(a) 合法。  
含义：得到iter的值，并且iter迭代器前进一个对象。  
(b) 合法。  
含义：iter指向的对象的值+1。  
(c) 不合法。  
iter没有empty()成员，应该先解引用得到对象再调用empty()成员。  
(d) 合法。  
调用iter所指对象的empty()成员。  
(e) 合法。  
iter指向的对象的值+1。  
(f) 合法。  
调用iter所指对象的empty()成员,同时iter迭代器前进一个对象。

* **练习4.21**  
[4.21程序代码](4.21.cpp)  

* **练习4.22**  
[4.22条件运算符程序代码](4.22/4.22_conditionOperator.cpp)  
[4.22if程序代码](4.22/4.22_if.cpp)  
我觉得if语句更容易理解。

* **练习4.23**  
因为“+”的优先级比条件运算符高，从而s会先与s[size()-1]进行加操作，然后与's'相比较，从而引发错误。  
修改：
```
string p1 = s + (s[s.size() - 1] == 's' ? "" : "s");
```

* **练习4.24**  
如果满足左结合律，求值顺序是：
```
((grade > 90) ? "high pass" : (grade < 60)) ? "fail" : "pass";
```


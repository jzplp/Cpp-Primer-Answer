* **练习9.1**  
(a) 先用一个vector尾插元素，读取结束后再用sort排序。  
(b) deque  
(c) 先用一个vector尾插元素，读取结束后再用sort排序。  

* **练习9.2**  
```
std::list<std::deque<int>> l;
```

* **练习9.3**  
1. 两个迭代器必须都指向同一个容器中的元素或者是尾元素之后的位置
2. 构成一个左闭合区间  

* **练习9.4**  
[9.4程序代码](9.4.cpp)  

* **练习9.5**  
[9.5程序代码](9.5.cpp)  

* **练习9.6**  
```
while(iter1 != iter2)
```

* **练习9.7**  
```
std::vector<int>::const_iterator
```

* **练习9.8**  
```
使用 std::list<std::string>::value_type
写入 std::list<std::string>::reference
```

* **练习9.9**  
返回的迭代器是否可以修改指向的元素内容。

* **练习9.10**  
```
it1     vector<int>::iterator
it2     vector<int>::const_iterator
it3     vector<int>::const_iterator
it4     vector<int>::const_iterator
```

* **练习9.11**  
[9.11程序代码](9.11.cpp)  

* **练习9.12**  
接受一个容器的构造函数必须元素和容器类型都相同，接受迭代器的构造函数不要求类型相同，只要元素类型可转换为新构造的容器的元素类型即可。

* **练习9.13**  
[9.13程序代码](9.13.cpp)  

* **练习9.14**  
[9.14程序代码](9.14.cpp)  

* **练习9.15**  
[9.15程序代码](9.15.cpp)  

* **练习9.16**  
[9.16程序代码](9.16.cpp)  

* **练习9.17**  
c1和c2必须是同一种类型的容器，且保存同一种类型的元素，且元素类型是可比较的。

* **练习9.18**  
[9.18程序代码](9.18.cpp)  

* **练习9.19**  
除了类型变化，程序基本不需要做改变。  
[9.19程序代码](9.19.cpp)  

* **练习9.20**  
[9.20程序代码](9.20.cpp)  

* **练习9.21**  
循环将每次在vector的头部插入，每次插入vector都将移动所有元素

* **练习9.22**  
插入一次之后迭代器就失效了  
修改：  
```
vecor<int>::iterator iter = iv.begin(), mid = iv.begin() + iv.size()/2;
while(iter != mid)
    if(*iter == some_val)
    {
        iter = iv.insert(iter, 2 * some_val);
        mid = iv.begin() + iv.size()/2;
    }
```

* **练习9.23**  
他们的值相同，都等于c中唯一的元素值

* **练习9.24**  
(不能正常执行)  
[9.24错误实验程序代码](9.24.cpp)  

* **练习9.25**  
如果elem1与elem2相等，则不会删除元素，且返回当前位置的迭代器。  
如果elem2是尾后迭代器，则返回尾后迭代器。  
如果elem1与elem2都是尾后迭代器，则不会删除元素，且返回尾后迭代器。  

* **练习9.26**  
[9.26程序代码](9.26.cpp)  

* **练习9.27**  
[9.27程序代码](9.27.cpp)  

* **练习9.28**  
[9.28程序代码](9.28.cpp)  

* **练习9.29**  
vec中添加75个值初始化的元素。再删去90个元素。

* **练习9.30**  
元素必须是内置类型或者有默认构造函数。

* **练习9.31**  
[9.31forward_list程序代码](9.31/9.31_forward_list.cpp)  
[9.31list程序代码](9.31/9.31_list.cpp)  

* **练习9.32**  
不合法，后置递增运算符最好不要与同一对象在同一表达式中出现，其行为未定义

* **练习9.33**  
迭代器失效，程序变为死循环。  
[9.33错误程序代码](9.33.cpp)  
但实际测试，程序结果正常。猜想可能是由于编译器优化，或者存储空间没有重新分配所致。  

* **练习9.34**  
程序会变为死循环  
[9.34错误程序代码](9.34.cpp) 

* **练习9.35**  
size指实际存储的元素个数，capacity指的是分配的内存空间，大于等于size

* **练习9.36**  
不可能

* **练习9.37**  
因为list是链表，空间是在每个元素建立时分配的。
array是数组，空间是在array初始化时直接分配的，不能修改

* **练习9.38**  
在我的电脑的标准库实现中，是以2的幂次增长的。  
[9.38程序代码](9.38.cpp)  

* **练习9.39**  
先分配1024个空间，再读取输入存入sver中，如果输入多于683个，那么将扩大空间到输入的1.5倍

* **练习9.40**  
读入256个，capacity是1024  
读入512个，capacity是1024  
读入1000个，capacity是1500  
读入1048个，capacity是1572  

* **练习9.41**   
[9.41程序代码](9.41.cpp)  

* **练习9.42**   
先用reserve分配至少100的空间

* **练习9.43**   
[9.43程序代码](9.43.cpp)  

* **练习9.44**   
[9.44程序代码](9.44.cpp)  

* **练习9.45**   
[9.45程序代码](9.45.cpp)  

* **练习9.46**   
[9.46程序代码](9.46.cpp)  

* **练习9.47**   

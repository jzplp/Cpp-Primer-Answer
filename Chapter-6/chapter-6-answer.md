* **练习6.1**  
 形参是函数定义的时候需要传递的的参数声明。
 实参是函数调用时用来传递给形参的实际参数。
 
* **练习6.2**  
(a) 无错误。
(b) 没有返回类型
(c) 形参名重复，左大括号缺失
(d) 没有大括号

* **练习6.3**  
[6.3程序代码](6.3.cpp)  

* **练习6.4**  
[6.4程序代码](6.4.cpp)  

* **练习6.5**  
[6.5程序代码](6.5.cpp)  

* **练习6.6**  
[6.6程序代码](6.6.cpp)  
形参是局部变量，是函数调用时定义并初始化的参数，函数结束时销毁。  
函数内的局部变量是在执行路径经过时定义并初始化的，函数结束时销毁。  
静态变量是在执行路径经过时定义并初始化的，函数束后不销毁。

* **练习6.7**  
[6.7程序代码](6.7.cpp)  

* **练习6.8**  
[6.8程序代码](6.8/Chapter6.h)  

* **练习6.9**  
[6.9fact程序代码](6.9/fact.cpp)  
[6.9factMain程序代码](6.9/factMain.cpp)  

* **练习6.10**  
[6.10程序代码](6.10.cpp)  

* **练习6.11**  
[6.11程序代码](6.11.cpp)  

* **练习6.12**  
[用引用重写6.10程序代码](6.12_6.10_references.cpp)  

* **练习6.13**  
一个形参是引用类型，调用时是传引用。一个形参非引用类型，调用时是传值。

* **练习6.14**  
交换两个整数的值，应该用引用类型。
传入的值作为控制变量进行变化，不能用引用类型。

* **练习6.15**  
const string &s : 因为s可能很大，传值可能消耗资源大，而我们又不能修改s中的值，因此使用const  
char c : 普通char字符  
srting::size_type &occurs : 因为值必须要传回调用函数，所以必须使用非常量引用类型。  
如果s是普通引用，如果函数编写出错，就可能出现修改s中值的现象。  
如果occurs是常量引用，我们就无法修改occurs的值，也就无法记录出现的次数。

* **练习6.16**  
不能接受常量和类型转换的变量。
修改：
```
bool is_empty(const string &s) { return s.empty(); }
```

* **练习6.17**  
[6.17程序代码](6.17.cpp)  
使用的参数类型不同，因为一个需要修改string，一个不需要。

* **练习6.18**  
```
(a)
bool compare(const matrix &m1, const matrix &m2);
vector<int>::iterator change_val(int i, vector<int>::iterator vp);
```

* **练习6.19**  
(a) 不合法，参数过多。  
(b) 合法。  
(c) 合法。  
(d) 合法。

* **练习6.20**  
如果不修改对象的值，就应该是常量引用。  
很多常量和参数转换就无法使用。

* **练习6.21**  
[6.21程序代码](6.21.cpp)  

* **练习6.22**  
[6.22程序代码](6.22.cpp)  

* **练习6.23**  
[6.23程序代码](6.23.cpp)  

* **练习6.24**  
没有什么严重错误，可以正常编译并运行。就是实际传入的是指针，数组的维度10会被忽略。  
改正后：  
```
void print(const int ia[])
{
    for(size_t i = 0; i != 10; ++i)
        cout << ia[i] <<endl;
}
```

* **练习6.25**  
[6.25程序代码](6.25.cpp)  

* **练习6.26**  
[6.26程序代码](6.26.cpp)  

* **练习6.27**  
[6.27程序代码](6.27.cpp)  

* **练习6.28**  
int类型

* **练习6.29**  
可以是引用，如果是引用必须是const引用。也可以是非引用类型。

* **练习6.30**  
[6.30错误程序代码](6.30.cpp)  
编译器错误信息：
```
[Error] return-statement with no value, in function returning 'bool' [-fpermissive]
```

* **练习6.31**  
如果引用的是函数中定义的局部变量则返回引用无效。  

* **练习6.32**  
合法。对数组ia的每个元素赋给下标值。

* **练习6.33**  
[6.33程序代码](6.33.cpp)  

* **练习6.34**  
如果传入的是小于1的数则函数会无限递归。

* **练习6.35**  
因为后面还使用到了val的值，容易产生未定义的值。

* **练习6.36**  
```
std::string (&func(string s))[10];
```

* **练习6.37**  
```
(1)
typedef std::string arr[10];
arr &func(std::string s);
(2)
using arr = std::string [10];
arr &func(std::string s);
(3)
auto func(std::string s) -> std::string (&)[10];
(4)
std::string arr[10];
decltype(arr) &func(std::string s);
```
都挺好用的。

* **练习6.38**  
```
decltype(odd) &arrPtr(int i)
{
    return (i % 2) ? odd : even;
}
```

* **练习6.39**  
(a) 重复声明  
(b) 重复声明  
(c) 正常重载

* **练习6.40**  
(a) 正确  
(b) 错误，带有默认值的参数应该在没有默认值的参数后面。  

* **练习6.41**  
(a) 非法  
(b) 合法  
(c) 合法但不符合初衷。

* **练习6.42**  
[6.42程序代码](6.42.cpp)  

* **练习6.43**  
(a) 声明和定义放在头文件中  
(b) 声明放在头文件中，定义放在源文件中  

* **练习6.44**  
[6.44程序代码](6.44.cpp)  

* **练习6.45**  
部分函数可以是内联函数。如果全部改写工作量太大，故略过

* **练习6.46**  
不可以。因为string不是字面值类型

* **练习6.47**  
[打开NDEBUG调试重写6.33程序代码](6.47/6.47_6.33_openDEBUG.cpp)  
[关闭NDEBUG调试重写6.33程序代码](6.47/6.47_6.33_closeDEBUG.cpp)  

* **练习6.48**  
不合理。因为当调试关闭时，如果不是因为s == sought而结束的循环，程序可能不能合理的处理这种情况。

* **练习6.49**  
候选函数：  
1.与被调用的函数同名  
2.声明在调用点可见  
可行函数：  
从候选函数中选出的可以被实参调用的函数

* **练习6.50**  
```
(a) 不合法，调用有二义性
(b) void f(int);
(c) void f(int, int);
(d) void f(double, double = 3.14);
```
 
 * **练习6.51**  
 [6.51程序代码](6.51.cpp)  
 
* **练习6.52**  

* **练习6.1**  
 形参是函数定义的时候需要传递的的参数声明。
 实参是函数调用时用来传递给形参的实际参数。
 
* **练习6.2**  
(a) 无错误。
(b) 没有返回类型
(c) 形参名重复，左大括号缺失
(d) 没有大括号

* **练习6.3**  
[6.3程序代码](6.3.cpp)  

* **练习6.4**  
[6.4程序代码](6.4.cpp)  

* **练习6.5**  
[6.5程序代码](6.5.cpp)  

* **练习6.6**  
[6.6程序代码](6.6.cpp)  
形参是局部变量，是函数调用时定义并初始化的参数，函数结束时销毁。  
函数内的局部变量是在执行路径经过时定义并初始化的，函数结束时销毁。  
静态变量是在执行路径经过时定义并初始化的，函数束后不销毁。

* **练习6.7**  
[6.7程序代码](6.7.cpp)  

* **练习6.8**  
[6.8程序代码](6.8/Chapter6.h)  

* **练习6.9**  
[6.9fact程序代码](6.9/fact.cpp)  
[6.9factMain程序代码](6.9/factMain.cpp)  

* **练习6.10**  
[6.10程序代码](6.10.cpp)  

* **练习6.11**  
[6.11程序代码](6.11.cpp)  

* **练习6.12**  
[用引用重写6.10程序代码](6.12_6.10_references.cpp)  

* **练习6.13**  
一个形参是引用类型，调用时是传引用。一个形参非引用类型，调用时是传值。

* **练习6.14**  
交换两个整数的值，应该用引用类型。
传入的值作为控制变量进行变化，不能用引用类型。

* **练习6.15**  
const string &s : 因为s可能很大，传值可能消耗资源大，而我们又不能修改s中的值，因此使用const  
char c : 普通char字符  
srting::size_type &occurs : 因为值必须要传回调用函数，所以必须使用非常量引用类型。  
如果s是普通引用，如果函数编写出错，就可能出现修改s中值的现象。  
如果occurs是常量引用，我们就无法修改occurs的值，也就无法记录出现的次数。

* **练习6.16**  
不能接受常量和类型转换的变量。
修改：
```
bool is_empty(const string &s) { return s.empty(); }
```

* **练习6.17**  
[6.17程序代码](6.17.cpp)  
使用的参数类型不同，因为一个需要修改string，一个不需要。

* **练习6.18**  
```
(a)
bool compare(const matrix &m1, const matrix &m2);
vector<int>::iterator change_val(int i, vector<int>::iterator vp);
```

* **练习6.19**  
(a) 不合法，参数过多。  
(b) 合法。  
(c) 合法。  
(d) 合法。

* **练习6.20**  
如果不修改对象的值，就应该是常量引用。  
很多常量和参数转换就无法使用。

* **练习6.21**  

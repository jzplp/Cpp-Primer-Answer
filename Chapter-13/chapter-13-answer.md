* **练习13.1**  
拷贝构造函数是类进行拷贝初始化时使用的构造函数。

* **练习13.2**  
对于该构造函数的调用会造成无限循环。

* **练习13.3**  
拷贝一个StrBlob时，拷贝了智能指针  
拷贝一个StrBlobPtr时，拷贝了智能指针和size_t类型

* **练习13.4**  
1. 这个函数被调用时
2. local初始化时 
3. new一个指针时  
答案书中没有写这条，这条可能会调用，也可能不会调用。但即使调用，也可能是调用的拷贝构造函数进行的直接初始化，并不是拷贝初始化  
4. *heap赋值时（拷贝赋值运算符）
5. pa数组初始化时，调用了2次  
6. return语句调用1次

* **练习13.5**  
[13.5 HasPtr类 程序代码](13.5.cpp)  

* **练习13.6**  
拷贝赋值运算符是控制类对象拷贝时候的的函数  
在对象赋值的时候使用  
如果类未定义拷贝复制运算符时，编译器会生成一个合成的  

* **练习13.7**  
与调用拷贝构造函数类似，拷贝一个StrBlob时，拷贝了智能指针  
拷贝一个StrBlobPtr时，拷贝了智能指针和size_t类型  

* **练习13.8**  
添加了拷贝复制运算符  
[13.8 HasPtr类 程序代码](13.8.cpp)  

* **练习13.9**  
析构函数是在类对象销毁时执行的函数。  
合成的析构函数一般用来销毁类对象内的对象。  
如果类未定义自己的析构函数，编译器会合成一个。  

* **练习13.10**  
销毁StrBlob对象：销毁一个shared_ptr对象。  
销毁StrBlobPtr对象：销毁一个weak_ptr对象和size_t对象。  

* **练习13.11**  
[13.11 HasPtr类 程序代码](13.11.cpp)  

* **练习13.12**  
1. accum销毁
2. item1销毁
3. item2销毁  
3次析构函数调用

* **练习13.13**  
[13.13程序代码](13.13.cpp)  

* **练习13.14**  


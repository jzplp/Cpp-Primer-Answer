* **练习13.1**  
拷贝构造函数是类进行拷贝初始化时使用的构造函数。

* **练习13.2**  
对于该构造函数的调用会造成无限循环。

* **练习13.3**  
拷贝一个StrBlob时，拷贝了智能指针  
拷贝一个StrBlobPtr时，拷贝了智能指针和size_t类型

* **练习13.4**  
1. 这个函数被调用时
2. local初始化时 
3. new一个指针时  
答案书中没有写这条，这条可能会调用，也可能不会调用。但即使调用，也可能是调用的拷贝构造函数进行的直接初始化，并不是拷贝初始化  
4. *heap赋值时（拷贝赋值运算符）
5. pa数组初始化时，调用了2次  
6. return语句调用1次

* **练习13.5**  
[13.5 HasPtr类 程序代码](13.5.cpp)  

* **练习13.6**  
拷贝赋值运算符是控制类对象拷贝时候的的函数  
在对象赋值的时候使用  
如果类未定义拷贝复制运算符时，编译器会生成一个合成的  

* **练习13.7**  
与调用拷贝构造函数类似，拷贝一个StrBlob时，拷贝了智能指针  
拷贝一个StrBlobPtr时，拷贝了智能指针和size_t类型  

* **练习13.8**  
添加了拷贝赋值运算符  
[13.8 HasPtr类 程序代码](13.8.cpp)  

* **练习13.9**  
析构函数是在类对象销毁时执行的函数。  
合成的析构函数一般用来销毁类对象内的对象。  
如果类未定义自己的析构函数，编译器会合成一个。  

* **练习13.10**  
销毁StrBlob对象：销毁一个shared_ptr对象。  
销毁StrBlobPtr对象：销毁一个weak_ptr对象和size_t对象。  

* **练习13.11**  
添加了析构函数  
[13.11 HasPtr类 程序代码](13.11.cpp)  

* **练习13.12**  
1. accum销毁
2. item1销毁
3. item2销毁  
3次析构函数调用

* **练习13.13**  
[13.13程序代码](13.13.cpp)  

* **练习13.14**  
输出相同的序号

* **练习13.15**  
会改变上一题中的输出结果，但是并不是我们想要的a，b，c的序号

* **练习13.16**  
会改变输出结果，改成了我们想要的a，b，c的序号

* **练习13.17**  
[13.17 numbered类 13.14合成的拷贝构造函数程序代码](13.17/numbered_syn.cpp)  
[13.17 numbered类 13.15自定义拷贝构造函数程序代码](13.17/numbered_copyCon.cpp)  
[13.17 numbered类 13.16引用参数f函数程序代码](13.17/numbered_referFun.cpp)  

* **练习13.18**  
[13.18 Employee类 程序代码](13.18.cpp)  

* **练习13.19**  
我认为Employee类应该禁止拷贝。因为员工是唯一的，复制是没有意义的。
[13.19 Employee类 程序代码](13.19.cpp)  

* **练习13.20**  
TextQuery参照书上的使用vector的，12章进行添加后的版本    
TextQuery类  
拷贝：拷贝一个shared_ptr和一个map  
赋值：赋值一个shared_ptr和一个map  
销毁：默认销毁一个shared_ptr和一个map  
QueryResult类  
拷贝：拷贝2个shared_ptr和一个string  
赋值：赋值2个shared_ptr和一个string  
销毁：默认销毁2个shared_ptr和一个string  

* **练习13.21**  
TextQuery参照书上的使用vector的，12章进行添加后的版本  
TextQuery类和QueryResult类中的指针成员都是智能指针，依赖于合成的操作即可正常使用。因此不需要定义拷贝控制成员。  
main.cpp仅用于本题测试  
[13.21 TextQuery.h程序代码](13.21/TextQuery.h)  
[13.21 TextQuery.cpp程序代码](13.21/TextQuery.cpp)  
[13.21 测试程序代码](13.21/main.cpp)  

* **练习13.22**  
使用之前练习中的代码，即可让HasPtr类具有值行为  
[13.11 HasPtr类 程序代码](13.11.cpp)  

* **练习13.23**  
